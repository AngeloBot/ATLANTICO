#include <PWMServo.h>
#include <SoftwareSerial.h>
#include <TinyGPS.h>
#include <HMC5883L.h>
#include <Wire.h> 
 
 
PWMServo servo; // Variável Servo
 
HMC5883L bussola; // Variável bussola


   float pos = 90;
   float soma_rumos = 0;
   float marcador_rumos = 0;
   float rumo_ideal;
   float rumo_real;
   float rumo_medio;
   float delta_rumo;
   float delta_rumo2;
   float erro_rumo;
   float erro_rumo2;
   bool em_bordo = false;
   bool estava_contra = false;
   float far_left = 0;
   float left = 0;
   float right = 0;
   float far_right = 0;
   float contador_pane_bordo = 0;
   float contador_pane_contra = 0;
   float distancia_waypoint = 99;
   float distancia;
   float latitude, longitude; //As variaveis podem ser float, para não precisar fazer nenhum cálculo
   int i; //Variável para contagem
   float precisao; //Variável parar o melhorar a precisao do valor aferido
   float declinationAngle; // compensaçao do desvio da bussola para cada waypoint em radianos
   
SoftwareSerial serial1(6, 7); // RX, TX
TinyGPS gps1;

void setup() {

   serial1.begin(9600);
   Serial.begin(9600);
   
 

   Serial.println("O GPS está aguardando pelo sinal dos satelites...");
   
   servo.attach(SERVO_PIN_A);  //Define a porta a ser ligada ao servo, a 9
   servo.write(90); // Inicia motor posição zero
   Serial.println("servo iniciado em 90");

   Wire.begin(); //Inicia a comunicação o I2C

   //Configura a bússola
   bussola = HMC5883L();
   bussola.SetScale(1.3);
   bussola.SetMeasurementMode(Measurement_Continuous);
}



void loop() {
   
  //GPS// 
   
  bool recebido = false;
  static unsigned long delayPrint;

  while (serial1.available()) {
     char cIn = serial1.read();
     recebido = (gps1.encode(cIn) || recebido);  //Verifica até receber o primeiro sinal dos satelites
  }

 if ( (recebido) && ((millis() - delayPrint) > 1000) ) {  //Mostra apenas após receber o primeiro sinal. Após o primeiro sinal, mostra a cada segundo.
     delayPrint = millis();
  
  //Latitude e Longitude
     
     unsigned long idadeInfo;
     gps1.f_get_position(&latitude, &longitude, &idadeInfo);   //O método f_get_position é mais indicado para retornar as coordenadas em variáveis float, para não precisar fazer nenhum cálculo 
  
     if (latitude != TinyGPS::GPS_INVALID_F_ANGLE) {
        Serial.print("Latitude: ");
        Serial.println(latitude, 6);  //Mostra a latitude com a precisão de 6 dígitos decimais
     }

     if (longitude != TinyGPS::GPS_INVALID_F_ANGLE) {
        Serial.print("Longitude: ");
        Serial.println(longitude, 6);  //Mostra a longitude com a precisão de 6 dígitos decimais
     }

 //Rumo Ideal

     //rumo_ideal (calculado a partir da posiçao atual e do proximo waypoint) 
     rumo_ideal = gps1.course_to(latitude, longitude, -23.578426, -46.744687);        //lat2 e lon2 numa lista de waypoints//
     Serial.print("Rumo Ideal (grau): ");
     Serial.println(float(rumo_ideal), 2);    
   
   //BUSSOLA//
   
    precisao = 0; //Zera a variável para uma nova leitura

    for(i=0;i<100;i++) { //Faz a leitura 100 e armazenar a somatória

    //Pega os dados necessários para o cálculo da bússola digital
    MagnetometerScaled scaled = bussola.ReadScaledAxis();
    int MilliGauss_OnThe_XAxis = scaled.XAxis;
    float heading = atan2(scaled.YAxis, scaled.XAxis);
    heading += declinationAngle;
  
    //Converte o valor aferido para angulo
    if(heading < 0) {
      heading += 2*PI;
    } 

   if(heading > 2*PI) {
      heading -= 2*PI;
    }  

    rumo_real = heading * 180/M_PI;

    precisao = precisao + rumo_real;
    delay(1);
  }

   rumo_real = precisao/100; //Pega a somatória e tira a média dos valores aferidos
   Serial.print("Rumo Real (grau): ");
   Serial.println(rumo_real);
   
     soma_rumos += rumo_real;
     marcador_rumos ++;

  }
     
     
     //PILOTO AUTOMÁTICO//
     
     if (marcador_rumos > 4 && !em_bordo){      //falta verificar a média dos hall
     Serial.println("iniciado piloto automatico"); 
     rumo_medio = soma_rumos / marcador_rumos;
     
     delta_rumo = rumo_medio - rumo_ideal;
     
       if (((delta_rumo) < -10 && (delta_rumo) > -180) || ((delta_rumo) > 10 && (delta_rumo) < 180)) {
        erro_rumo = abs(delta_rumo);
       }
     
       if (((delta_rumo) < 350  && (delta_rumo) > 180) || ((delta_rumo) > -350 && (delta_rumo) < -180)) {
        erro_rumo = abs(delta_rumo - 360);
       }
     
       //VENTO FAVORAVEL//
       if (far_left == 0 && left == 0 && right == 0 && far_right == 0) {
     
          if (((delta_rumo) < -10 && (delta_rumo) > -180) || ((delta_rumo) < 350  && (delta_rumo) > 180) ) {    //virar pra boreste
            if (!estava_contra) {
              pos += erro_rumo;
              Serial.println("virou a boreste no piloto automaatico favoravel");
            }
            else {     //orça um pouco, pq antes estava no contravento e o erro_rumo é grande
              pos += 5;
              Serial.println("orçou para boreste no piloto automatico favoravel");
            }
          }
          if (((delta_rumo) > 10 && (delta_rumo) < 180) || ((delta_rumo) > -350 && (delta_rumo) < -180)) {      //virar pra bombordo
            if (!estava_contra) {
              pos -= erro_rumo;
              Serial.println("virou a bombordo no piloto automatico favoravel");
            }
            else {
               pos -= 5;      //orça um pouco, pq antes estava no contravento e o erro_rumo é grande
               Serial.println("orçou a bombordo no piloto automatico favoravel");
            }   
         }
          estava_contra = false;
       }
     
      //VENTO CONTRA POR BORESTE//
      
      if (far_right == 1 || right == 1) {
        
         if (((delta_rumo) > 5 && (delta_rumo) < 180) || ((delta_rumo) > -355 && (delta_rumo) < -180)) {      //virar pra bombordo
         pos -= 5;
         Serial.println("arribou pq o rumo ideal está mais aberto");
         }
         
         if (far_right == 1 && right == 1) {
         pos -= 5;
         Serial.println("arribou a bombordo");
         }
         
         if (far_right == 0 && right == 1) {
         pos -= 15;
         Serial.println("arribou incisivamente a bombordo");
         contador_pane_contra += 1;
         Serial.print("contador pane contra = ");
         Serial.println(contador_pane_contra);
         }

         if (far_right == 1 && right == 0){
         Serial.println("orçando com vento por boreste");
         }
         
    
      estava_contra = true;
      }
      
      //VENTO CONTRA POR BOMBORDO//
     
      if (far_left == 1 || left == 1) {

         if (((delta_rumo) < -5 && (delta_rumo) > -180) || ((delta_rumo) < 355  && (delta_rumo) > 180) ) {    //virar pra boreste
         pos += 5;
         Serial.println("arribou pq o rumo ideal está mais aberto");
         }
      
         if (far_left == 1 && left == 1) {
         pos += 5;
         Serial.println("arribou a boreste");
         }
         
         if (far_left == 0 && left == 1) {
         pos += 15;
         Serial.println("arribou incisivamente a boreste");
         contador_pane_contra += 1;         
         Serial.print("contador pane contra = ");
         Serial.println(contador_pane_contra);
         }

         if (far_left == 1 && left == 0) {
         Serial.print("orçando com vento por bombordo");
         }
     
      estava_contra = true;
     }
    
          soma_rumos = 0;
          marcador_rumos = 0;
   }
     
     
     if (left == 0 && right == 0) {       //zera os marcadores de pane se o vento não está mais contra
         contador_pane_contra = 0;
         }
         
     
     //BORDO//
     
    delta_rumo2 = rumo_real - rumo_ideal;        //aqui usa o rumo_real, pq o rumo muda rápido durante o bordo
     
    if (((delta_rumo2) < -10 && (delta_rumo2) > -180) || ((delta_rumo2) > 10 && (delta_rumo2) < 180)) {
        erro_rumo2 = abs(delta_rumo);
       }
     
    if (((delta_rumo2) < 350  && (delta_rumo2) > 180) || ((delta_rumo2) > -350 && (delta_rumo2) < -180)) {
        erro_rumo2 = abs(delta_rumo - 360);
       }
     
     //BORDO A BORESTE//
     if (!em_bordo && far_right == 1 && right == 0 && (erro_rumo) > 90 && (((delta_rumo) < -10 && (delta_rumo) > -180) || ((delta_rumo) < 350  && (delta_rumo) > 180) ) ) {
           pos = 180;
           servo.write(pos);
           Serial.println("comando de bordo para boreste");
           delay(500);
           em_bordo = true;
         }
    
     //BORDO A BOMBORDO//
     
     if (!em_bordo && far_left == 1 && left == 0 && erro_rumo > 90 && (((delta_rumo) > 10 && (delta_rumo) < 180) || ((delta_rumo) > -350 && (delta_rumo) < -180))){
            pos = 0;
            servo.write(pos);
            Serial.println("comando de bordo para bombordo");
            delay(3000);
            em_bordo = true;
     }
     
     //FIM DO BORDO//
     
     if (em_bordo) {
        contador_pane_bordo += 1;
        delay(250);
        Serial.print("contador pane bordo = ");
        Serial.println(contador_pane_bordo);
        if (erro_rumo2 < 10) {     //talvez seja melhor usar aqui que o hall oposto ligue
           pos = 90;
           servo.write(pos);
           Serial.println("término de bordo");
           delay(3000);
           em_bordo = false;
           contador_pane_bordo = 0;
           }
     }
     
     //MODO PANE//
     
     if ((contador_pane_bordo > 30) || (contador_pane_contra > 20)) {
         pos = 90;
         em_bordo = false;
         estava_contra = false;
         servo.write(pos);
         Serial.println("modo pane acionado");
         delay(10000);
         contador_pane_bordo = 0;
         contador_pane_contra = 0;
     } 
     
     //MOVE SERVO//
     
     if (pos > 180) {     //impede angulos impossiveis pro servo
         pos = 180;
         Serial.println("leme corrigido para 180");
         }
     if (pos < 0) {
         pos = 0;
         Serial.println("leme corrigido para 0");
         }
         
     if (em_bordo == false) {
         servo.write(pos);
         //Serial.print("pos = ");
         //Serial.println(pos);
         // Serial.println("leme acionado em piloto automatico");
         delay(1000);       //talvez tenha que aumentar esse delay pra dar tempo do barco responder
         pos = 90;
         servo.write(pos);
         delay(1000);
         
         }              //talvez tenha que voltar um pouco o leme depois que mover
     
     
     
     //PROXIMO WAYPOINT
     
     distancia = gps1.distance_between(latitude, longitude, -23.0000, -45.0000);
     if (distancia < distancia_waypoint) {
     
     }
    
}
